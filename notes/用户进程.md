# 用户进程

PCB即可管理线程又可管理进程。

## PCB结构

```c
struct task_struct{
	uint32_t self_kernel_stack; 	//进程内核栈地址---esp0
	pid_t pid;						//进程ID
    pid_t parent_pid;
	enum task_status status;		//线程/进程ID
	char name[16];					//线程/进程名
	uint8_t priority;				//线程/进程 权重值(总时间片)
	uint8_t ticks;					//线程/进程 剩余时间片
	uint32_t elapsed_ticks;			//进程总共消耗的时间片
	struct list_elem ready_node;	//就绪队列节点
	struct list_elem all_node;	 	//全部队列节点
	uint32_t pgdir_vaddr; 			//页目录表在内核进程页表中的地址
	struct vmpool vaddr_pool;		//进程虚拟内存池
	struct mem_block_desc descs[MEM_DESC_CNT]; //用户内存管理
	int32_t fd_table[MAX_FILES_OPEN_PER_PROCESS]; //文件描述符数组
	uint32_t cwd_inode_no;          //工作目录inode号
    uint32_t stack_magic;			//魔术 --- 防止内核栈溢出 
};
```

其中**pgdir_vaddr** 和 **vaddr_pool** 只需在构建进程时初始化，构建线程时无需初始化。

## 创建用户进程

### 创建进程主函数

```c
void executeProcess(void* filename,char*process_name)
{
	enum int_status stat = closeInt();	//关中断，避免创建完线程信息后被执行
	struct task_struct* proc_pcb = thread_start(process_name,DEFAULT_PROI,&processBooter,filename); //初始化进程中的线程信息
	initUserVaddrPool(proc_pcb);  //创建用户虚拟地址池
	proc_pcb->pgdir_vaddr = (uint32_t)createPDT();	//创建页目录表
	setIntStatus(stat); //还原中断状态
}
```

### 创建用户虚拟地址池

```c
#define USER_VADDR_START 0x08048000
#define USER_STACK3_VADDR_START (0xc0000000-0x1000)
void initUserVaddrPool(struct task_struct*pthread)
{
	pthread->vaddr_pool.vm_start = USER_VADDR_START; //设置用户虚拟内存池起始地址为0x08048000
	uint32_t bitmap_pg_cnt = DIV_ROUND_UP((0xc0000000-USER_VADDR_START)/PG_SIZE/8,PG_SIZE);  //计算位图所需页面数量
	void*pbitmap = mallocKernelPage(bitmap_pg_cnt);  //从内核中申请空间
	ASSERT(pbitmap!=NULL);
	pthread->vaddr_pool.bitmap.pbitmap = pbitmap; 	 //设置位图
	pthread->vaddr_pool.bitmap.bitmap_byte_len = DIV_ROUND_UP((0xc0000000-USER_VADDR_START),PG_SIZE*8);
	initBitmap(&pthread->vaddr_pool.bitmap); //位图清0
}
```

### 创建用户页目录表

```c
void* createPDT()
{
	void*page_dir_vaddr = mallocKernelPage(1);  /*从内核内存值中申请一页页目录*/
	if(page_dir_vaddr == NULL) 
		return NULL;
	memcpy((void*)((uint32_t)page_dir_vaddr+768*4),(void*)(0xfffff000+768*4),255*4); /*映射内核高端1G内存到用户页目录表*/
	void*paddr= addr_v2p(page_dir_vaddr);	/*得到物理地址*/
	((uint32_t*)page_dir_vaddr)[1023] = (((uint32_t)paddr) | PG_US_U | PG_RW_W | PG_P_1);/*页目录最后一项赋值为该进程页目录表物理地址*/
	return page_dir_vaddr;
}
```

## 开启用户进程

### 中断栈结构

由于iret指令可以从高特权级向低特权级转移，因此需设置用户中断栈从而进入用户进程。

```c
/* 用户进程设置栈，从栈中进入特权级3 */
struct intr_stack{
	uint32_t vec_no;
	uint32_t edi;	
	uint32_t esi;
	uint32_t ebp;
	uint32_t esp_dummy;
	uint32_t ebx;	
	uint32_t edx;
	uint32_t ecx;
	uint32_t eax;
	uint32_t gs;	
	uint32_t fs;
	uint32_t es;
	uint32_t ds;
	
	uint32_t err_code;
	void* eip;         //用户进程执行函数
	uint32_t cs;       //用户进程代码段选择子
	uint32_t eflags;   //状态寄存器
	void*esp;          //用户进程栈
	uint32_t ss;	   //用户进程栈段选择子
};
```

### 用户进程启动器

由switch_to 调用 进程启动器设置内核进程栈和用户进程栈

```c
extern void int_exit(void);
static void processBooter(void* filename)
{
	void * function = filename; 			/*可执行文件加载到内存*/
	struct task_struct* pcb = getpcb();     
	pcb->self_kernel_stack += sizeof(struct thread_stack);
	struct intr_stack* proc_stack = (struct intr_stack*)(pcb->self_kernel_stack);
	memset(proc_stack,0,sizeof(struct intr_stack));
	/*设置内核进程栈*/
    proc_stack->esp_dummy = 0;
	proc_stack->ds = proc_stack->fs = proc_stack->es = SELECTOR_U_DATA;
	proc_stack->eip = function;
	proc_stack->cs = SELECTOR_U_CODE;
	proc_stack->eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);
	proc_stack->esp = (void*)((uint32_t)mallocOnePageByVaddr(PF_USER,(void*)USER_STACK3_VADDR_START)+PG_SIZE); 
	proc_stack->ss = SELECTOR_U_DATA;	
	/*设置用户进程栈*/
    struct intr_stack* user_stack = (struct intr_stack*)((uint32_t)proc_stack->esp-sizeof(struct intr_stack));
	memcpy(user_stack,proc_stack,sizeof(struct intr_stack)); //拷贝用户栈空间
    /*跳入中断*/
	asm volatile("movl %0,%%esp;jmp int_exit"::"g"(proc_stack):"memory");
}
```

## 进程调度

### 切换页表

```c
static void activatePDT(struct task_struct*pcb)
{
        void* pdt_paddr = (void*)0x100000;     //内核页表物理地址
        uint32_t pdt_vaddr = pcb->pgdir_vaddr; //pcb的虚拟地址
        if(pdt_vaddr!=NULL)                    //若为用户进程
                pdt_paddr = addr_v2p((void*)pdt_vaddr);
        asm volatile("movl %0,%%cr3"::"r"(pdt_paddr):"memory"); //加载页目录表物理地址到 cr3 完成页表切换
}
```

### 更改TSS中esp0

```c
void update_tss_esp(struct task_struct*pthread)
{
	TSS.esp0 = (uint32_t)pthread+PG_SIZE;
}
```

## fork子进程

1.拷贝父进程pcb给子进程pcb，重置子进程pcb内存块描述符，申请新PID

```c
static int32_t forkPCB(struct task_struct *child,struct task_struct *parent)
{
    memcpy(child,parent,PG_SIZE);
    child->elapsed_ticks = 0;
    child->pid = createPid();
    if(child->pid == -1) return -1;
    child->parent_pid = parent->pid;
    child->ticks = parent->priority;
    child->status = TASK_READY;
    child->pgdir_vaddr = NULL;
    memset(&child->ready_node,0,sizeof(struct list_elem));
    memset(&child->all_node,0,sizeof(struct list_elem));
    initMemBlockDesc(child->descs);
    return 0;
}
```

2.为子进程申请内存位图，拷贝父进程位图

```c
static int32_t copyVaddrBitmap(struct task_struct *child,struct task_struct*parent)
{
    uint32_t vaddr_bitmap_page_cnt = DIV_ROUND_UP(DIV_ROUND_UP((KERNEL_VADDR_START-USER_VADDR_START)/PG_SIZE,8),PG_SIZE);
    void* vaddr = mallocKernelPage(vaddr_bitmap_page_cnt);
    if(vaddr == NULL) return -1;
    child->vaddr_pool.bitmap.pbitmap = (uint8_t*)vaddr;
    child->vaddr_pool.bitmap.bitmap_byte_len = DIV_ROUND_UP((KERNEL_VADDR_START-USER_VADDR_START)/PG_SIZE,8);
    memcpy(child->vaddr_pool.bitmap.pbitmap,parent->vaddr_pool.bitmap.pbitmap,parent->vaddr_pool.bitmap.bitmap_byte_len);
    return 0;
}
```

3.为子进程创建页目录表

```c
static int32_t create_pdt(struct task_struct*pcb)
{
    if(pcb->pgdir_vaddr!=NULL) return -1;
    pcb->pgdir_vaddr = (uint32_t)createPDT(); 
    return 0;
}
```

4.拷贝父进程用户数据到子进程

```c
static int32_t copyProcessData(struct task_struct * child,struct task_struct*parent,char* buf)
{
    uint32_t byte_index = 0;
    uint32_t bit_index = 0;
    uint32_t bitmap_byte_len = child->vaddr_pool.bitmap.bitmap_byte_len;
    uint8_t * p = parent->vaddr_pool.bitmap.pbitmap;
    for(byte_index=0;byte_index<bitmap_byte_len;byte_index++){
        if(p[byte_index]==0){
            continue;
        }
        for(bit_index = 0;bit_index<8;bit_index++){
            if((p[byte_index]&(BIT_MASK<<bit_index)) == 0)
                continue;
            uint32_t vaddr = parent->vaddr_pool.vm_start + (byte_index*8+bit_index)*PG_SIZE;
            memcpy(buf,(void*)vaddr,PG_SIZE); //父进程数据拷贝到内核缓冲区
            activatePDT(child); //切换子进程页表
            if(malloc1PageByVaddrWithoutVaddrPool(PF_USER,(void*)vaddr)==NULL)
                return -1;
            memcpy((void*)vaddr,buf,PG_SIZE); //拷贝内核缓冲区数据到子进程
            activatePDT(parent);//切换父进程页表
        }
    }
    return 0;
}
```

5.修改子进程pcb中返回值eax，设置eip

```c
extern void int_exit(void);
static void build_child_stack(struct task_struct*child)
{
    struct intr_stack * int_stack = (struct intr_stack*)(((uint32_t)child) + PG_SIZE - sizeof(struct intr_stack));
    int_stack -> eax = 0;
    struct thread_stack * thread_stack = (struct thread_stack*)(((uint32_t)int_stack) - sizeof(struct thread_stack)+12);
    thread_stack->eip = (void(*)(thread_func,void*))&int_exit;
    child->self_kernel_stack = (uint32_t)thread_stack;
}
```

6.更新文件打开状态

```c
static void update_file_table(struct task_struct*child)
{
    int i = 0;
    for(;i<MAX_FILES_OPEN_PER_PROCESS;i++){
        if(child->fd_table[i]!=-1&&i>2){
            file_table[child->fd_table[i]].fd_inode->i_open_cnts++;
        }
    }
}
```

sys_fork

```c
pid_t sys_fork(void)
{
    struct task_struct * child_pcb = mallocKernelPage(1); //从内核申请子进程PCB内存
    if(child_pcb==NULL) return -1;
    struct task_struct * parent_pcb = getpcb();
    uint32_t roll_val = 0;
    if(forkPCB(child_pcb,parent_pcb)) goto rollback; 	//设置子进程PCB参数
    if(copyVaddrBitmap(child_pcb,parent_pcb)==-1) goto rollback;
    if(create_pdt(child_pcb)==-1) goto rollback;
    char* io_buf = mallocKernelPage(1);  //申请内核拷贝内存
    if(io_buf == NULL) {
        roll_val = 1;
        goto rollback;
    }
    if(copyProcessData(child_pcb,parent_pcb,io_buf)==-1){ //拷贝用户态数据到子进程
        roll_val = 1;
        goto rollback;
    }
    build_child_stack(child_pcb);  //设置内核态子进程栈：等待被调度
    if(find_elem(&thread_all_list,&child_pcb->all_node)==true || find_elem(&thread_ready_list,&child_pcb->ready_node)==true){
        roll_val = 1;
        goto rollback;
    }
    list_append(&thread_all_list,&child_pcb->all_node);
    list_append(&thread_ready_list,&child_pcb->ready_node);
    update_file_table(child_pcb); //更新inode打开状态
    freeKernelPage(io_buf);		//释放缓冲区
    return child_pcb->pid;
rollback:
    switch (roll_val){
        case 1:
            freeKernelPage(io_buf);
        case 0:       
            freeKernelPage(child_pcb);
            break;
    }
    return -1;    
}
```

