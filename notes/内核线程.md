# 内核线程

## 进程控制块(PCB)

### PCB简述

​	PCB用于表示并跟踪操作系统中每一个进程的状态和信息。PCB 是进程在操作系统中存在和管理的基本单位，包括了操作系统需要的所有信息来维持进程的运行。

​	每个内核线程/用户进程都含有一个PCB用来实现线程切换，每个PCB占4KB大小（一页），在内核空间申请内存。

​	内核栈指针esp0指向PCB区域。

### 数据结构实现

```c
struct task_struct{
	uint32_t self_kernel_stack; 	//进程内核栈地址---esp0
	pid_t pid;						//进程ID
	enum task_status status;		//线程/进程ID
	char name[16];					//线程/进程名
	uint8_t priority;				//线程/进程 权重值(总时间片)
	uint8_t ticks;					//线程/进程 剩余时间片
	uint32_t elapsed_ticks;			//进程总共消耗的时间片
	struct list_elem ready_node;	//就绪队列节点
	struct list_elem all_node;	 	//全部队列节点
	uint32_t pgdir_vaddr; 			//页目录表在内核进程页表中的地址
	struct vmpool vaddr_pool;		//进程虚拟内存池
	struct mem_block_desc descs[MEM_DESC_CNT]; //用户内存管理
	uint32_t stack_magic;			//魔术 --- 防止内核栈溢出 
};
```

```c
/* 进程初始化设置 switch_to 进入 function */
struct thread_stack{
	uint32_t ebp;
	uint32_t ebx;
	uint32_t edi;
	uint32_t esi;
	
	void(*eip)(thread_func fun,void*args); //线程函数启动器地址
	void* unused_retaddr;  				  //线程回收器地址
	thread_func function;				  //内核线程执行函数
	void*func_args;						 //该函数所需参数
};
```



## 线程切换

### 创建内核线程

#### 创建线程主函数

```c
/*创建内核线程 返回线程PCB*/
struct task_struct* thread_start(char* name/*线程名*/,int prio/*线程执行滴答数*/,thread_func func/*线程执行函数*/,void* args/*函数参数*/)
{
	struct task_struct* thread = (struct task_struct*)mallocKernelPage(1);
	if(thread == NULL) return NULL;
	memset(thread,0,sizeof(struct task_struct));
	initThreadBase(thread,name,prio); //初始化PCB中基本信息
	initThreadStack(thread,func,args);//构建函数调用栈
	initMemBlockDesc(thread->descs);  //初始化内存描述符
	enum int_status stat = closeInt();
	ASSERT(find_elem(&thread_ready_list,&thread->ready_node)==false);
	list_append(&thread_ready_list,&thread->ready_node); 		//添加到就绪队列尾

	ASSERT(find_elem(&thread_all_list,&thread->all_node)==false);
	list_append(&thread_all_list,&thread->all_node);			//添加到所有队列尾部
	setIntStatus(stat);
	return thread;
}
```

#### 创建PCB基本信息

```c
static void initThreadBase(struct task_struct* thread,const char*name,int prio)
{
	ASSERT(thread != NULL);
	memset(thread,0,sizeof(struct task_struct));
	thread->self_kernel_stack = ((uint32_t)thread+PG_SIZE);
	thread->status=TASK_READY;
	strcpy(thread->name,name);
	thread->priority = prio;
	thread->ticks = prio;
	thread->elapsed_ticks = 0;
	thread->pgdir_vaddr = NULL;
	thread->stack_magic = 0x20040104;
}
```

#### 创建函数调用栈

```c
static void initThreadStack(struct task_struct*thread,thread_func func,void*args)
{
	ASSERT(thread!=NULL);

	thread->self_kernel_stack -= (sizeof(struct intr_stack));
	thread->self_kernel_stack -= (sizeof(struct thread_stack));
	struct thread_stack* thread_stack = (struct thread_stack*)(thread->self_kernel_stack);
	thread_stack->eip = &execFunc;
	thread_stack->retaddr = &threadRecoverer;
	thread_stack->function = func;
	thread_stack->func_args = args;
	thread_stack->ebp=thread_stack->ebx=thread_stack->edi=thread_stack->esi=0;
}

```

其中eip指向的**函数启动器**如下：

```c
static void execFunc(thread_func func,void*args)
{
	enableInt(); //第一次轮到该线程时为关中断状态，需打开中断
	func(args);  //执行线程函数
}
```

retaddr指向**线程回收器**

```c
static void threadRecoverer(void)
{
	closeInt();
	struct task_struct* cur_pcb = getpcb();
	cur_pcb->status = TASK_DIED;
	schedule();
}
```

#### 构建PCB内存描述符

```c
/*初始化内存管理符*/
void initMemBlockDesc(struct mem_block_desc*descs)
{
	//16 32 64 128 256 512 1024
	uint32_t size = 16;
	uint32_t desc_index = 0;
	for(;desc_index<MEM_DESC_CNT;desc_index++){
		list_init(&descs[desc_index].free_list); 
		descs[desc_index].block_size=size;
		descs[desc_index].blocks_per_arena = (PG_SIZE-sizeof(struct arena))/size;
		size*=2;
	}
}
```

### 线程调度

#### schedule & switch_to

```c

void schedule(void)
{
	enum int_status stat = closeInt();
	struct task_struct* cur_pcb = getpcb();     //获取当前pcb
	if(cur_pcb -> status == TASK_RUNNING){	    //为时间片耗尽引起的线程切换
		ASSERT(find_elem(&thread_ready_list,&cur_pcb->ready_node)==false);
		list_append(&thread_ready_list,&cur_pcb->ready_node);//将当前PCB加入到就绪队列中
		cur_pcb -> ticks = cur_pcb->priority;  //重新设置时间片
		cur_pcb -> status = TASK_READY;
	}else if (cur_pcb -> status == TASK_DIED){  //若为线程执行完
		list_remove(&cur_pcb->all_node);
	}else{ //线程被阻塞
        
	}
	if(list_empty(&thread_ready_list)){ /*若没有可执行的线程则唤醒idle线程*/
		thread_unblock(idle_thread);
	}
	thread_tag =list_pop(&thread_ready_list);                  			  
	struct task_struct*next_pcb = (struct task_struct*)elem2PCBentry(struct task_struct,ready_node,thread_tag);//从就绪队列中获取下个执行线程的PCB
	activateProcess(next_pcb); //切换下一线程的页表和TSS
	next_pcb -> status = TASK_RUNNING;
	if (cur_pcb -> status == TASK_DIED) 
		switch_to_and_free(cur_pcb,next_pcb); //切换并回收
	else 
		switch_to(cur_pcb,next_pcb);          //切换esp执行下一线程
	setIntStatus(stat);
}
```

```asm
[bits 32]
section .text
;void switch_to(task_struct* cur_pcb,task_struct* new_pcb);
global switch_to
switch_to:
	push esi      	;保存中断程序能正确执行完的所需寄存器
	push edi
	push ebx
	push ebp

	mov eax,[esp+20]
	mov [eax],esp			;保存当前执行线程esp到pcb中的第一个成员
	mov eax,[esp+24]
	mov esp,[eax]			;切换esp为上一线程PCB中保存的esp

	pop ebp
	pop ebx		   ;弹出上一线程保存的基本寄存器
	pop edi
	pop esi
	ret
```

#### 阻塞线程

设置当前线程状态并切换下一线程,不将本线程重新加入就绪队列,**如需唤醒该线程需调用者主动保存该线程PCB**

```c
/*设置当前线程状态并切换下一线程 不将本线程重新加入就绪队列 如需唤醒该线程需调用者主动保存该线程PCB*/
void thread_block(enum task_status stat)
{
	ASSERT(stat == TASK_BLOCKED || stat == TASK_WAITING || stat == TASK_HANGING);
	enum int_status old_int_status = closeInt();
	struct task_struct*cur_pcb = getpcb();	
	cur_pcb -> status = stat; //设置当前线程状态
	asm volatile("pushl %ds;pushl %es;pushl %fs;pushl %gs;pusha;"); //保存所有寄存器
	schedule();  //切换下一线程
	asm volatile("popa;popl %gs;popl %fs;popl %es;popl %ds");	   //还原寄存器
	setIntStatus(old_int_status);
}
```



#### 唤醒线程

**将保存的被阻塞的线程PCB重新加入到就绪队列中，不补充消耗过的始终滴答**

```c
void thread_unblock(struct task_struct*pcb)
{
	enum int_status old_int_status = closeInt();
	ASSERT(pcb->status == TASK_BLOCKED || pcb->status == TASK_WAITING || pcb->status == TASK_HANGING);
	if(pcb->status != TASK_READY){
		ASSERT(!find_elem(&thread_ready_list,&pcb->ready_node));
		list_push(&thread_ready_list,&pcb->ready_node); 	//阻塞线程加到队首以优先调用
		pcb->status = TASK_READY;
	}
	setIntStatus(old_int_status);
}
```

#### 挂起线程

主动挂起当前进程 **（不重新设置proi）**

```c
/*主动挂起当前进程 （不重新设置proi）*/
void thread_yield(void)
{
	struct task_struct * pcb = getpcb();
	enum int_status stat = closeInt();
	ASSERT(find_elem(&thread_ready_list,&pcb->ready_node)==false);
	list_append(&thread_ready_list,&pcb->ready_node); //重新加入当前线程到就绪队列队尾
	pcb -> status = TASK_READY;
	schedule(); //切换线程
	setIntStatus(stat);
}
```

## 初始化线程模块

```c
/*
 *Description: init main_thread , thread_ready_list , thread_all_list
 */
void initThread(void)
{
	put_str("init thread start\n");
	list_init(&thread_ready_list);
	list_init(&thread_all_list);
	make_main_thread();
	idle_thread = thread_start("idle",10,&idle,NULL); //初始化idle线程
	put_str("init thread done\n");
}
```

### 创建内核main线程

```c
static void make_main_thread(void)
{
	struct task_struct* main_thread = getpcb();
	initThreadBase(main_thread,"main",31);
	main_thread->status = TASK_RUNNING;
	main_thread->self_kernel_stack = 0xc009f000;   //初始化main线程栈
	ASSERT(!find_elem(&thread_all_list,&main_thread->all_node));
	list_append(&thread_all_list,&main_thread->all_node); 
	thread_tag = &main_thread->ready_node;
}
```



### idle线程

```c
idle_thread = thread_start("idle",10,&idle,NULL); //初始化idle线程
```

```c
/*系统空闲时运行的线程*/
static void idle(void* arg UNUSED)
{
	while(1){
		thread_block(TASK_BLOCKED); 			//阻塞当前线程，若线程队列空时被唤醒
		asm volatile ("sti; hlt;":::"memory");   //开中断，挂起CPU，当有中断产生后继续执行
	}
}
```

